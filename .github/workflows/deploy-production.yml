name: Deploy Backend to Production

on:
  push:
    branches: [ main, master ]
      
  workflow_dispatch:
    inputs:
      run_migrations:
        description: 'Run database migrations'
        required: true
        default: 'false'
        type: choice
        options:
          - 'true'
          - 'false'
      run_seeds:
        description: 'Run database seeds (requires migrations to be true or already executed)'
        required: true
        default: 'false'
        type: choice
        options:
          - 'true'
          - 'false'
      seed_type:
        description: 'Type of seeds to run'
        required: false
        default: 'production'
        type: choice
        options:
          - production
          - development

env:
  DOCKER_IMAGE_NAME: rexel-backend-prod
  VPS_DEPLOY_PATH: ~/rexel-modern/backend
  CONTAINER_NAME: rexel-backend-prod
  CONTAINER_PORT: 3333
  DB_CONTAINER_NAME: rexel-postgres-prod
  MINIO_CONTAINER_NAME: rexel-minio-prod

jobs:
  prepare-directory:
    name: Prepare VPS Directory
    runs-on: ubuntu-latest
    environment: production
    steps:
      - name: Create deployment directory on VPS
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.VPS_SSH_PRIVATE_KEY }}
          port: 22
          script: |
            mkdir -p ${{ env.VPS_DEPLOY_PATH }}
            mkdir -p ${{ env.VPS_DEPLOY_PATH }}/backups
            mkdir -p ${{ env.VPS_DEPLOY_PATH }}/images
            mkdir -p ${{ env.VPS_DEPLOY_PATH }}/uploads
            mkdir -p ${{ env.VPS_DEPLOY_PATH }}/minio-data
            mkdir -p ${{ env.VPS_DEPLOY_PATH }}/logs
            chmod 755 ${{ env.VPS_DEPLOY_PATH }}/logs

  docker-setup:
    name: Verify Docker Setup
    runs-on: ubuntu-latest
    environment: production
    steps:
      - name: Verify and setup Docker environment
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.VPS_SSH_PRIVATE_KEY }}
          port: 22
          script: |
            echo "=== Docker Environment Check ==="
            
            # Check if Docker is installed
            if ! command -v docker &> /dev/null; then
              echo "ðŸ”§ Docker not found, installing..."
              curl -fsSL https://get.docker.com -o get-docker.sh
              sudo sh get-docker.sh
              rm get-docker.sh
            else
              echo "âœ… Docker is installed: $(docker --version)"
            fi
            
            # Check if Docker service is running
            if ! sudo systemctl is-active --quiet docker; then
              echo "ðŸ”§ Starting Docker service..."
              sudo systemctl start docker
              sudo systemctl enable docker
            else
              echo "âœ… Docker service is running"
            fi
            
            # Check if user is in docker group
            if ! groups $USER | grep -q '\bdocker\b'; then
              echo "ðŸ”§ Adding user to docker group..."
              sudo usermod -aG docker $USER
              echo "âš ï¸  User added to docker group. Testing access..."
            else
              echo "âœ… User is in docker group"
            fi
            
            # Test Docker access with retry logic
            echo "ðŸ§ª Testing Docker access..."
            max_attempts=5
            attempt=1
            
            while [ $attempt -le $max_attempts ]; do
              if docker ps &> /dev/null; then
                echo "âœ… Docker access test successful!"
                break
              else
                echo "âš ï¸  Docker access test failed (attempt $attempt/$max_attempts)"
                if [ $attempt -eq $max_attempts ]; then
                  echo "âŒ Docker access still failing after $max_attempts attempts"
                  echo "Trying with sudo as fallback..."
                  if sudo docker ps &> /dev/null; then
                    echo "âœ… Docker works with sudo"
                    echo "âš ï¸  Will use sudo for Docker commands"
                  else
                    echo "âŒ Docker not working even with sudo"
                    exit 1
                  fi
                else
                  echo "Waiting 5 seconds before retry..."
                  sleep 5
                  # Try to refresh group membership
                  newgrp docker || true
                fi
              fi
              attempt=$((attempt + 1))
            done
            
            # Install Docker Compose if not present
            if ! command -v docker-compose &> /dev/null && ! docker compose version &> /dev/null; then
              echo "ðŸ”§ Installing Docker Compose..."
              sudo curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
              sudo chmod +x /usr/local/bin/docker-compose
            else
              echo "âœ… Docker Compose is available"
            fi
            
            # Final verification
            echo "=== Final Docker Environment Status ==="
            docker --version || sudo docker --version
            docker compose version || docker-compose --version || sudo docker compose version
            echo "Docker daemon status: $(sudo systemctl is-active docker)"
            echo "User groups: $(groups $USER)"

  checkout:
    name: Checkout Code
    runs-on: ubuntu-latest
    needs: [docker-setup, prepare-directory]
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Upload source code
        uses: actions/upload-artifact@v4
        with:
          name: source-code
          path: .
          retention-days: 1

  build-docker:
    name: Build Docker Image
    runs-on: ubuntu-latest
    environment: production
    needs: [checkout]
    steps:
      - name: Download source code
        uses: actions/download-artifact@v4
        with:
          name: source-code
      
      - name: Create production .env file
        run: |
          cat > .env << EOF
          NODE_ENV=production
          PORT=3333
          HOST=0.0.0.0
          LOG_LEVEL=info
          APP_KEY=${{ secrets.APP_KEY }}
          
          # Database Configuration
          DB_CONNECTION=pg
          DB_HOST=${{ secrets.DB_HOST }}
          DB_PORT=${{ secrets.DB_PORT }}
          DB_USER=${{ secrets.DB_USER }}
          DB_PASSWORD=${{ secrets.DB_PASSWORD }}
          DB_DATABASE=${{ secrets.DB_DATABASE }}
          
          # MinIO Configuration
          MINIO_HOST=${{ secrets.MINIO_HOST }}
          MINIO_PORT=${{ secrets.MINIO_PORT }}
          MINIO_ROOT_USER=${{ secrets.MINIO_ROOT_USER }}
          MINIO_ROOT_PASSWORD=${{ secrets.MINIO_ROOT_PASSWORD }}
          MINIO_ACCESS_KEY=${{ secrets.MINIO_ACCESS_KEY }}
          MINIO_SECRET_KEY=${{ secrets.MINIO_SECRET_KEY }}
          MINIO_USE_SSL=${{ secrets.MINIO_USE_SSL }}
          
          # Redis Configuration (optional)
          REDIS_HOST=${{ secrets.REDIS_HOST }}
          REDIS_PORT=${{ secrets.REDIS_PORT }}
          REDIS_PASSWORD=${{ secrets.REDIS_PASSWORD }}
          
          # JWT Configuration
          JWT_SECRET=${{ secrets.JWT_SECRET }}
          
          # CORS Configuration
          CORS_ORIGINS=${{ secrets.CORS_ORIGINS }}
          
          # Email Configuration (optional)
          SMTP_HOST=${{ secrets.SMTP_HOST }}
          SMTP_PORT=${{ secrets.SMTP_PORT }}
          SMTP_USERNAME=${{ secrets.SMTP_USERNAME }}
          SMTP_PASSWORD=${{ secrets.SMTP_PASSWORD }}
          SMTP_FROM=${{ secrets.SMTP_FROM }}
          
          # Frontend URL
          FRONTEND_URL=${{ secrets.FRONTEND_URL }}
    
          # Storage Configuration
          STORAGE_DRIVER=minio
          EOF
      
      - name: Verify .env file created
        run: |
          echo "Checking if .env file exists..."
          ls -la .env
          echo "Environment variables count:"
          wc -l .env
      
      - name: Generate image tag
        id: tag
        run: |
          SHORT_SHA=$(echo ${{ github.sha }} | cut -c1-7)
          TIMESTAMP=$(date +%Y%m%d-%H%M%S)
          IMAGE_TAG="${{ env.DOCKER_IMAGE_NAME }}:${SHORT_SHA}-${TIMESTAMP}"
          echo "image-tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "short-sha=${SHORT_SHA}" >> $GITHUB_OUTPUT
          echo "timestamp=${TIMESTAMP}" >> $GITHUB_OUTPUT
      
      - name: Build Docker image
        run: |
          docker build -t ${{ steps.tag.outputs.image-tag }} .
          docker tag ${{ steps.tag.outputs.image-tag }} ${{ env.DOCKER_IMAGE_NAME }}:latest
      
      - name: Save Docker image to tar
        run: |
          docker save ${{ steps.tag.outputs.image-tag }} > rexel-backend-prod.tar
          ls -lh rexel-backend-prod.tar

      - name: Upload Docker image and compose file
        uses: actions/upload-artifact@v4
        with:
          name: docker-image-prod
          path: |
            rexel-backend-prod.tar
            docker-compose.prod.yml
            Caddyfile
          retention-days: 7

  transfer-image:
    name: Transfer Image to VPS
    runs-on: ubuntu-latest
    environment: production
    needs: [prepare-directory, build-docker]
    steps:
      - name: Download Docker image
        uses: actions/download-artifact@v4
        with:
          name: docker-image-prod
      
      - name: Transfer Docker image and compose files to VPS
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.VPS_SSH_PRIVATE_KEY }}
          port: 22
          source: "rexel-backend-prod.tar,docker-compose.prod.yml,Caddyfile"
          target: ${{ env.VPS_DEPLOY_PATH }}/
      
      - name: Create backup and organize files
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.VPS_SSH_PRIVATE_KEY }}
          port: 22
          script: |
            # Create images directory if it doesn't exist
            mkdir -p ${{ env.VPS_DEPLOY_PATH }}/images
            
            # Backup previous image if exists
            if [ -f ${{ env.VPS_DEPLOY_PATH }}/images/rexel-backend-prod-current.tar ]; then
              mv ${{ env.VPS_DEPLOY_PATH }}/images/rexel-backend-prod-current.tar ${{ env.VPS_DEPLOY_PATH }}/backups/rexel-backend-prod-backup-$(date +%Y%m%d-%H%M%S).tar
            fi
            
            # Move new image to images directory
            mv ${{ env.VPS_DEPLOY_PATH }}/rexel-backend-prod.tar ${{ env.VPS_DEPLOY_PATH }}/images/rexel-backend-prod-current.tar
            
            # Verify Caddyfile exists
            if [ ! -f ${{ env.VPS_DEPLOY_PATH }}/Caddyfile ]; then
              echo "âŒ Caddyfile not found in deployment directory!"
              ls -la ${{ env.VPS_DEPLOY_PATH }}/
              exit 1
            else
              echo "âœ… Caddyfile found and ready"
            fi

  load-and-run:
    name: Load and Run Services with Docker Compose
    runs-on: ubuntu-latest
    environment: production
    needs: [transfer-image]
    steps:
      - name: Deploy with Docker Compose
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.VPS_SSH_PRIVATE_KEY }}
          port: 22
          script: |
            cd ${{ env.VPS_DEPLOY_PATH }}
            
            # Detect if sudo is needed for Docker commands
            USE_SUDO=""
            if ! docker ps &> /dev/null; then
              if sudo docker ps &> /dev/null; then
                echo "âš ï¸  Using sudo for Docker commands"
                USE_SUDO="sudo "
              else
                echo "âŒ Docker not accessible even with sudo"
                exit 1
              fi
            else
              echo "âœ… Docker accessible without sudo"
            fi
            
            # Create production .env file
            cat > .env << EOF
            NODE_ENV=production
            PORT=3333
            HOST=0.0.0.0
            LOG_LEVEL=info
            APP_KEY=${{ secrets.APP_KEY }}
            
            # Database Configuration
            DB_CONNECTION=pg
            DB_HOST=db
            DB_PORT=5432
            DB_USER=${{ secrets.DB_USER }}
            DB_PASSWORD=${{ secrets.DB_PASSWORD }}
            DB_DATABASE=${{ secrets.DB_DATABASE }}
            
            # MinIO Configuration
            MINIO_HOST=minio
            MINIO_PORT=9000
            MINIO_ACCESS_KEY=${{ secrets.MINIO_ACCESS_KEY }}
            MINIO_SECRET_KEY=${{ secrets.MINIO_SECRET_KEY }}
            MINIO_USE_SSL=false
            MINIO_BUCKET=${{ secrets.MINIO_BUCKET }}
            MINIO_ROOT_USER=${{ secrets.MINIO_ROOT_USER }}
            MINIO_ROOT_PASSWORD=${{ secrets.MINIO_ROOT_PASSWORD }}
            
            # Redis Configuration (optional)
            REDIS_HOST=redis
            REDIS_PORT=6379
            REDIS_PASSWORD=${{ secrets.REDIS_PASSWORD }}
            
            # JWT Configuration
            JWT_SECRET=${{ secrets.JWT_SECRET }}
            
            # CORS Configuration
            CORS_ORIGINS=${{ secrets.CORS_ORIGINS }}
            
            # Email Configuration (optional)
            SMTP_HOST=${{ secrets.SMTP_HOST }}
            SMTP_PORT=${{ secrets.SMTP_PORT }}
            SMTP_USERNAME=${{ secrets.SMTP_USERNAME }}
            SMTP_PASSWORD=${{ secrets.SMTP_PASSWORD }}
            SMTP_FROM=${{ secrets.SMTP_FROM }}
            
            # Frontend URL
            FRONTEND_URL=${{ secrets.FRONTEND_URL }}
            
            # Storage Configuration
            STORAGE_DRIVER=minio
            EOF
            
            # Create rexel-network if it doesn't exist
            if ! ${USE_SUDO}docker network ls | grep -q rexel-network; then
              echo 'Creating rexel-network...'
              ${USE_SUDO}docker network create rexel-network
            else
              echo 'rexel-network already exists'
            fi
            
            # Load the new Docker image
            ${USE_SUDO}docker load < images/rexel-backend-prod-current.tar
            
            # Tag the loaded image as latest for docker-compose
            IMAGE_NAME=$(${USE_SUDO}docker images --format "table {{.Repository}}:{{.Tag}}" | grep rexel-backend-prod | grep -v latest | head -n 1)
            ${USE_SUDO}docker tag $IMAGE_NAME rexel-backend-prod:latest
            
            # Stop existing services
            echo 'Stopping existing services...'
            ${USE_SUDO}docker compose -f docker-compose.prod.yml down || echo 'No existing services to stop'
            
            # Start infrastructure services first (db, minio, redis)
            echo 'Starting infrastructure services...'
            ${USE_SUDO}docker compose -f docker-compose.prod.yml up -d db minio redis
            
            # Wait for database to be ready
            echo "Waiting for database to be ready..."
            until ${USE_SUDO}docker compose -f docker-compose.prod.yml exec -T db pg_isready -U ${{ secrets.DB_USER }}; do
              echo "Database not ready yet, waiting..."
              sleep 2
            done
            
            # Create database if not exists
            echo "Creating database ${{ secrets.DB_DATABASE }} if not exists..."
            ${USE_SUDO}docker compose -f docker-compose.prod.yml exec -T db psql -U ${{ secrets.DB_USER }} -c "SELECT 'CREATE DATABASE \"${{ secrets.DB_DATABASE }}\"' WHERE NOT EXISTS (SELECT FROM pg_database WHERE datname = '${{ secrets.DB_DATABASE }}')\\gexec"
            
            # Wait for MinIO to be ready
            echo "Waiting for MinIO to be ready..."
            until ${USE_SUDO}docker compose -f docker-compose.prod.yml exec -T minio mc ready local; do
              echo "MinIO not ready yet, waiting..."
              sleep 2
            done
            
            # Create MinIO bucket if not exists
            echo "Creating MinIO bucket ${{ secrets.MINIO_BUCKET }} if not exists..."
            ${USE_SUDO}docker compose -f docker-compose.prod.yml exec -T minio mc mb local/${{ secrets.MINIO_BUCKET }} || echo "Bucket already exists"
            
            # Set bucket policy to public read for public files
            ${USE_SUDO}docker compose -f docker-compose.prod.yml exec -T minio mc anonymous set public local/${{ secrets.MINIO_BUCKET }}/public || echo "Could not set public policy"
            
            # Verify database is accessible
            echo "Verifying database is accessible..."
            ${USE_SUDO}docker compose -f docker-compose.prod.yml exec -T db psql -U ${{ secrets.DB_USER }} -d "${{ secrets.DB_DATABASE }}" -c "SELECT 1;" > /dev/null
            echo "Database is ready!"
            
            # Give infrastructure services a moment to settle
            echo "Waiting 10 seconds before starting application..."
            sleep 10
            
            # Start application and Caddy services
            echo 'Starting application and Caddy services...'
            
            # Verify Caddyfile before starting
            if [ ! -f Caddyfile ]; then
              echo "âŒ Caddyfile not found! Cannot start Caddy."
              ls -la .
              exit 1
            fi
            
            # Start both services
            ${USE_SUDO}docker compose -f docker-compose.prod.yml up -d app caddy
            
            # Wait for services to start
            echo 'Waiting for services to start...'
            sleep 15
            
            # Check if services are running
            echo 'Checking service status...'
            echo 'ðŸ“‹ Container Status:'
            ${USE_SUDO}docker ps -f name=rexel- --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
            
            # Check main containers
            app_running=$(${USE_SUDO}docker ps -q -f name=${{ env.CONTAINER_NAME }})
            caddy_running=$(${USE_SUDO}docker ps -q -f name=rexel-caddy-prod)
            
            if [ ! -z "$app_running" ]; then
              echo 'âœ… Application container is running!'
            else
              echo 'âŒ Application container failed to start!'
              ${USE_SUDO}docker compose -f docker-compose.prod.yml logs app
              exit 1
            fi
            
            if [ ! -z "$caddy_running" ]; then
              echo 'âœ… Caddy reverse proxy is running!'
            else
              echo 'âš ï¸  Caddy container not running'
            fi
            
            echo 'Deployment completed - services are starting up...'

  run-migrations:
    name: Run Database Migrations
    runs-on: ubuntu-latest
    environment: production
    needs: [load-and-run]
    if: ${{ github.event.inputs.run_migrations == 'true' || github.event_name == 'push' }}
    steps:
      - name: Run migrations
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.VPS_SSH_PRIVATE_KEY }}
          port: 22
          script: |
            cd ${{ env.VPS_DEPLOY_PATH }}
            
            # Detect if sudo is needed for Docker commands
            USE_SUDO=""
            if ! docker ps &> /dev/null; then
              if sudo docker ps &> /dev/null; then
                echo "âš ï¸  Using sudo for Docker commands"
                USE_SUDO="sudo "
              else
                echo "âŒ Docker not accessible even with sudo"
                exit 1
              fi
            fi
            
            echo "Running database migrations..."
            ${USE_SUDO}docker compose -f docker-compose.prod.yml exec -T app node ace migration:run --force
            
            if [ $? -eq 0 ]; then
              echo "âœ… Migrations completed successfully!"
            else
              echo "âŒ Migration failed!"
              ${USE_SUDO}docker compose -f docker-compose.prod.yml logs app
              exit 1
            fi

  run-seeds:
    name: Run Database Seeds
    runs-on: ubuntu-latest
    environment: production
    needs: [run-migrations]
    if: ${{ github.event.inputs.run_seeds == 'true' && (github.event.inputs.run_migrations == 'true' || github.event_name == 'push') }}
    steps:
      - name: Run seeds
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.VPS_SSH_PRIVATE_KEY }}
          port: 22
          script: |
            cd ${{ env.VPS_DEPLOY_PATH }}
            
            # Detect if sudo is needed for Docker commands
            USE_SUDO=""
            if ! docker ps &> /dev/null; then
              if sudo docker ps &> /dev/null; then
                echo "âš ï¸  Using sudo for Docker commands"
                USE_SUDO="sudo "
              else
                echo "âŒ Docker not accessible even with sudo"
                exit 1
              fi
            fi
            
            SEED_TYPE="${{ github.event.inputs.seed_type || 'production' }}"
            echo "Running database seeds (type: $SEED_TYPE)..."
            
            if [ "$SEED_TYPE" = "production" ]; then
              # Run main seeder which should handle production data
              ${USE_SUDO}docker compose -f docker-compose.prod.yml exec -T app node ace db:seed --files="database/seeders/main_seeder.ts"
            else
              # Run all seeders for development data
              ${USE_SUDO}docker compose -f docker-compose.prod.yml exec -T app node ace db:seed
            fi
            
            if [ $? -eq 0 ]; then
              echo "âœ… Seeds completed successfully!"
            else
              echo "âŒ Seeds failed!"
              ${USE_SUDO}docker compose -f docker-compose.prod.yml logs app
              exit 1
            fi

  health-check:
    name: Final Health Check
    runs-on: ubuntu-latest
    environment: production
    needs: [load-and-run]
    if: always()
    steps:
      - name: Perform comprehensive health check
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.VPS_SSH_PRIVATE_KEY }}
          port: 22
          script: |
            cd ${{ env.VPS_DEPLOY_PATH }}
            
            # Detect if sudo is needed for Docker commands
            USE_SUDO=""
            if ! docker ps &> /dev/null; then
              if sudo docker ps &> /dev/null; then
                echo "âš ï¸  Using sudo for Docker commands"
                USE_SUDO="sudo "
              else
                echo "âŒ Docker not accessible even with sudo"
                exit 1
              fi
            fi
            
            echo "=== COMPREHENSIVE HEALTH CHECK ==="
            
            # Check container status
            echo "ðŸ“‹ Container Status:"
            ${USE_SUDO}docker ps -f name=rexel- --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
            
            # Check Caddy specifically
            echo -e "\nðŸŒ Caddy Reverse Proxy Status:"
            if [ $(${USE_SUDO}docker ps -q -f name=rexel-caddy-prod) ]; then
              echo "âœ… Caddy container is running"
              ${USE_SUDO}docker logs --tail=5 rexel-caddy-prod
            else
              echo "âŒ Caddy container not running"
              echo "Available containers:"
              ${USE_SUDO}docker ps -a -f name=rexel-caddy-prod
            fi
            
            # Check application logs (last 10 lines)
            echo -e "\nðŸ“ Application Logs (last 10 lines):"
            ${USE_SUDO}docker compose -f docker-compose.prod.yml logs --tail=10 app
            
            # Test database connection (optional check)
            echo -e "\nðŸ—„ï¸  Database Connection Test:"
            if ${USE_SUDO}docker compose -f docker-compose.prod.yml exec -T app node ace migration:status > /dev/null 2>&1; then
              echo "âœ… Database connection successful"
            else
              echo "âš ï¸  Database connection test failed (services may still be starting)"
            fi
            
            # Test MinIO connection (optional check)
            echo -e "\nðŸ“¦ MinIO Connection Test:"
            if ${USE_SUDO}docker compose -f docker-compose.prod.yml exec -T minio mc ls local/${{ secrets.MINIO_BUCKET }} > /dev/null 2>&1; then
              echo "âœ… MinIO connection successful"
            else
              echo "âš ï¸  MinIO connection test failed (services may still be starting)"
            fi
            
            # Simple container check instead of API test
            echo -e "\nðŸŒ Services Status:"
            app_running=$(${USE_SUDO}docker ps -q -f name=rexel-backend-prod)
            caddy_running=$(${USE_SUDO}docker ps -q -f name=rexel-caddy-prod)
            
            if [ ! -z "$app_running" ]; then
              echo "âœ… Application container is running"
            else
              echo "âŒ Application container not running"
            fi
            
            if [ ! -z "$caddy_running" ]; then
              echo "âœ… Caddy container is running"
            else
              echo "âŒ Caddy container not running"
            fi
            
            # Check disk space
            echo -e "\nðŸ’¾ Disk Space:"
            df -h ${{ env.VPS_DEPLOY_PATH }}
            
            echo -e "\n=== HEALTH CHECK COMPLETE ==="

  cleanup:
    name: Cleanup
    runs-on: ubuntu-latest
    environment: production
    needs: [load-and-run]
    if: always()
    steps:
      - name: Cleanup old Docker images and files
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.VPS_SSH_PRIVATE_KEY }}
          port: 22
          script: |
            # Detect if sudo is needed for Docker commands
            USE_SUDO=""
            if ! docker ps &> /dev/null; then
              if sudo docker ps &> /dev/null; then
                echo "âš ï¸  Using sudo for Docker commands"
                USE_SUDO="sudo "
              else
                echo "âŒ Docker not accessible even with sudo"
                exit 1
              fi
            fi
            
            # Remove dangling images
            ${USE_SUDO}docker image prune -f
            
            # Keep only the 3 most recent backup images
            cd ${{ env.VPS_DEPLOY_PATH }}/backups
            ls -t rexel-backend-prod-backup-*.tar 2>/dev/null | tail -n +4 | xargs -r rm -f
            
            # Clean up old logs (keep last 7 days)
            find ${{ env.VPS_DEPLOY_PATH }} -name "*.log" -type f -mtime +7 -delete 2>/dev/null || true
            
            echo "âœ… Cleanup completed"

      - name: Deployment Summary
        run: |
          echo "## ðŸš€ Rexel Modern Backend Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Setting | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|---------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| **Environment** | Production |" >> $GITHUB_STEP_SUMMARY
          echo "| **Repository** | ${{ github.repository }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Commit** | ${{ github.sha }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Run Migrations** | ${{ github.event.inputs.run_migrations || 'auto (on push)' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Run Seeds** | ${{ github.event.inputs.run_seeds || 'false' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Seed Type** | ${{ github.event.inputs.seed_type || 'production' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Container** | ${{ env.CONTAINER_NAME }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Port** | ${{ env.CONTAINER_PORT }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Deploy Path** | ${{ env.VPS_DEPLOY_PATH }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ“‹ Services Deployed" >> $GITHUB_STEP_SUMMARY
          echo "- ðŸš€ **Rexel Backend** (AdonisJS 6)" >> $GITHUB_STEP_SUMMARY
          echo "- ðŸŒ **Caddy Reverse Proxy** (Load Balancer & SSL)" >> $GITHUB_STEP_SUMMARY
          echo "- ðŸ—„ï¸ **PostgreSQL Database**" >> $GITHUB_STEP_SUMMARY
          echo "- ðŸ“¦ **MinIO Object Storage**" >> $GITHUB_STEP_SUMMARY
          echo "- ðŸ—ƒï¸  **Redis Cache** (optional)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ”— Next Steps" >> $GITHUB_STEP_SUMMARY
          echo "1. Verify API endpoints are responding correctly" >> $GITHUB_STEP_SUMMARY
          echo "2. Test file upload functionality" >> $GITHUB_STEP_SUMMARY
          echo "3. Check application logs for any issues" >> $GITHUB_STEP_SUMMARY
          echo "4. Update frontend environment variables if needed" >> $GITHUB_STEP_SUMMARY
