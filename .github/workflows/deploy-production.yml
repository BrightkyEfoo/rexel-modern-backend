name: Deploy Backend to Production

on:
  push:
    branches: [ main, master ]
      
  workflow_dispatch:
    inputs:
      run_migrations:
        description: 'Run database migrations'
        required: true
        default: 'false'
        type: choice
        options:
          - 'true'
          - 'false'
      run_seeds:
        description: 'Run database seeds (requires migrations to be true or already executed)'
        required: true
        default: 'false'
        type: choice
        options:
          - 'true'
          - 'false'
      seed_type:
        description: 'Type of seeds to run'
        required: false
        default: 'production'
        type: choice
        options:
          - production
          - development

env:
  DOCKER_IMAGE_NAME: kesimarket-backend-prod
  VPS_DEPLOY_PATH: ~/kesimarket-modern/backend
  CONTAINER_NAME: kesimarket-backend-prod
  CONTAINER_PORT: 3333
  DB_CONTAINER_NAME: kesimarket-postgres-prod
  MINIO_CONTAINER_NAME: kesimarket-minio-prod

jobs:
  prepare-directory:
    name: Prepare VPS Directory
    runs-on: ubuntu-latest
    environment: production
    steps:
      - name: Create deployment directory on VPS
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.VPS_SSH_PRIVATE_KEY }}
          port: 22
          script: |
            mkdir -p ${{ env.VPS_DEPLOY_PATH }}
            mkdir -p ${{ env.VPS_DEPLOY_PATH }}/backups
            mkdir -p ${{ env.VPS_DEPLOY_PATH }}/images
            mkdir -p ${{ env.VPS_DEPLOY_PATH }}/uploads
            mkdir -p ${{ env.VPS_DEPLOY_PATH }}/minio-data


  docker-setup:
    name: Verify Docker Setup
    runs-on: ubuntu-latest
    environment: production
    steps:
      - name: Verify and setup Docker environment
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.VPS_SSH_PRIVATE_KEY }}
          port: 22
          script: |
            echo "=== Docker Environment Check ==="
            
            # Check if Docker is installed
            if ! command -v docker &> /dev/null; then
              echo "üîß Docker not found, installing..."
              curl -fsSL https://get.docker.com -o get-docker.sh
              sudo sh get-docker.sh
              rm get-docker.sh
            else
              echo "‚úÖ Docker is installed: $(docker --version)"
            fi
            
            # Check if Docker service is running
            if ! sudo systemctl is-active --quiet docker; then
              echo "üîß Starting Docker service..."
              sudo systemctl start docker
              sudo systemctl enable docker
            else
              echo "‚úÖ Docker service is running"
            fi
            
            # Check if user is in docker group
            if ! groups $USER | grep -q '\bdocker\b'; then
              echo "üîß Adding user to docker group..."
              sudo usermod -aG docker $USER
              echo "‚ö†Ô∏è  User added to docker group. Testing access..."
            else
              echo "‚úÖ User is in docker group"
            fi
            
            # Test Docker access with retry logic
            echo "üß™ Testing Docker access..."
            max_attempts=5
            attempt=1
            
            while [ $attempt -le $max_attempts ]; do
              if docker ps &> /dev/null; then
                echo "‚úÖ Docker access test successful!"
                break
              else
                echo "‚ö†Ô∏è  Docker access test failed (attempt $attempt/$max_attempts)"
                if [ $attempt -eq $max_attempts ]; then
                  echo "‚ùå Docker access still failing after $max_attempts attempts"
                  echo "Trying with sudo as fallback..."
                  if sudo docker ps &> /dev/null; then
                    echo "‚úÖ Docker works with sudo"
                    echo "‚ö†Ô∏è  Will use sudo for Docker commands"
                  else
                    echo "‚ùå Docker not working even with sudo"
                    exit 1
                  fi
                else
                  echo "Waiting 5 seconds before retry..."
                  sleep 5
                  # Try to refresh group membership
                  newgrp docker || true
                fi
              fi
              attempt=$((attempt + 1))
            done
            
            # Install Docker Compose if not present
            if ! command -v docker-compose &> /dev/null && ! docker compose version &> /dev/null; then
              echo "üîß Installing Docker Compose..."
              sudo curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
              sudo chmod +x /usr/local/bin/docker-compose
            else
              echo "‚úÖ Docker Compose is available"
            fi
            
            # Setup shared Docker network for frontend/backend communication
            echo "=== Setting up shared Docker network ==="
            NETWORK_NAME="kesimarket-net"
            
            # Determine if we need to use sudo
            USE_SUDO=""
            if ! docker ps &> /dev/null; then
              USE_SUDO="sudo "
              echo "‚ö†Ô∏è  Using sudo for Docker commands"
            fi
            
            # Check if network exists
            if ${USE_SUDO}docker network ls | grep -q $NETWORK_NAME; then
              echo "‚úÖ Network '$NETWORK_NAME' already exists"
              ${USE_SUDO}docker network inspect $NETWORK_NAME --format '{{.Name}}: {{.Driver}}'
            else
              echo "üîß Creating shared network '$NETWORK_NAME'..."
              ${USE_SUDO}docker network create $NETWORK_NAME --driver bridge
              if [ $? -eq 0 ]; then
                echo "‚úÖ Network '$NETWORK_NAME' created successfully!"
              else
                echo "‚ùå Failed to create network '$NETWORK_NAME'"
                exit 1
              fi
            fi
            
            # Verify network details
            echo "üìã Network details:"
            ${USE_SUDO}docker network inspect $NETWORK_NAME --format '{{json .}}' | grep -E '"Name"|"Driver"|"Scope"' || true
            
            # Final verification
            echo "=== Final Docker Environment Status ==="
            docker --version || sudo docker --version
            docker compose version || docker-compose --version || sudo docker compose version
            echo "Docker daemon status: $(sudo systemctl is-active docker)"
            echo "User groups: $(groups $USER)"
            echo "Shared network status: $(${USE_SUDO}docker network ls | grep $NETWORK_NAME || echo 'Not found')"

  checkout:
    name: Checkout Code
    runs-on: ubuntu-latest
    needs: [docker-setup, prepare-directory]
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Upload source code
        uses: actions/upload-artifact@v4
        with:
          name: source-code
          path: .
          retention-days: 1

  build-docker:
    name: Build Docker Image
    runs-on: ubuntu-latest
    environment: production
    needs: [checkout]
    steps:
      - name: Download source code
        uses: actions/download-artifact@v4
        with:
          name: source-code
      
      - name: Create production .env file
        run: |
          cat > .env << EOF
          NODE_ENV=production
          PORT=3333
          HOST=0.0.0.0
          LOG_LEVEL=info
          APP_KEY=${{ secrets.APP_KEY }}
          
          # Database Configuration (Internal PostgreSQL)
          DB_CONNECTION=pg
          DB_HOST=db
          DB_PORT=5432
          DB_USER=${{ secrets.DB_USER }}
          DB_PASSWORD=${{ secrets.DB_PASSWORD }}
          DB_DATABASE=${{ secrets.DB_DATABASE }}
          
          # MinIO Configuration (Internal Service)
          MINIO_HOST=minio
          MINIO_PORT=9000
          MINIO_ACCESS_KEY=${{ secrets.MINIO_ACCESS_KEY }}
          MINIO_SECRET_KEY=${{ secrets.MINIO_SECRET_KEY }}
          MINIO_USE_SSL=false
          MINIO_BUCKET=${{ secrets.MINIO_BUCKET }}
          MINIO_PUBLIC_ENDPOINT=${{ secrets.MINIO_PUBLIC_ENDPOINT }}
          
          # Redis Configuration (Internal Service)
          REDIS_HOST=redis
          REDIS_PORT=6379
          REDIS_PASSWORD=${{ secrets.REDIS_PASSWORD }}
          
          # Typesense Configuration (Internal Service)
          TYPESENSE_HOST=typesense
          TYPESENSE_PORT=8108
          TYPESENSE_API_KEY=${{ secrets.TYPESENSE_API_KEY }}
          
          # JWT Configuration
          JWT_SECRET=${{ secrets.JWT_SECRET }}
          
          # CORS Configuration
          CORS_ORIGINS=${{ secrets.CORS_ORIGINS }}
          
          # Email Configuration (optional)
          SMTP_HOST=${{ secrets.SMTP_HOST }}
          SMTP_PORT=${{ secrets.SMTP_PORT }}
          SMTP_USERNAME=${{ secrets.SMTP_USERNAME }}
          SMTP_PASSWORD=${{ secrets.SMTP_PASSWORD }}
          SMTP_FROM=${{ secrets.SMTP_FROM }}
          MAIL_USERNAME=${{ secrets.MAIL_USERNAME }}
          GOOGLE_APP_SECRET=${{ secrets.GOOGLE_APP_SECRET }}
          
          # Frontend URL
          FRONTEND_URL=${{ secrets.FRONTEND_URL }}
    
          # Storage Configuration
          STORAGE_DRIVER=minio
          EOF
      
      - name: Verify .env file created
        run: |
          echo "Checking if .env file exists..."
          ls -la .env
          echo "Environment variables count:"
          wc -l .env
      
      - name: Generate image tag
        id: tag
        run: |
          SHORT_SHA=$(echo ${{ github.sha }} | cut -c1-7)
          TIMESTAMP=$(date +%Y%m%d-%H%M%S)
          IMAGE_TAG="${{ env.DOCKER_IMAGE_NAME }}:${SHORT_SHA}-${TIMESTAMP}"
          echo "image-tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "short-sha=${SHORT_SHA}" >> $GITHUB_OUTPUT
          echo "timestamp=${TIMESTAMP}" >> $GITHUB_OUTPUT
      
      - name: Build Docker image
        run: |
          docker build -t ${{ steps.tag.outputs.image-tag }} .
          docker tag ${{ steps.tag.outputs.image-tag }} ${{ env.DOCKER_IMAGE_NAME }}:latest
      
      - name: Save Docker image to tar
        run: |
          docker save ${{ steps.tag.outputs.image-tag }} > kesimarket-backend-prod.tar
          ls -lh kesimarket-backend-prod.tar

      - name: Upload Docker image and compose file
        uses: actions/upload-artifact@v4
        with:
          name: docker-image-prod
          path: |
            kesimarket-backend-prod.tar
            docker-compose.prod.yml
          retention-days: 7

  transfer-image:
    name: Transfer Image to VPS
    runs-on: ubuntu-latest
    environment: production
    needs: [prepare-directory, build-docker]
    steps:
      - name: Download Docker image
        uses: actions/download-artifact@v4
        with:
          name: docker-image-prod
      
      - name: Transfer Docker image and compose files to VPS
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.VPS_SSH_PRIVATE_KEY }}
          port: 22
          source: "kesimarket-backend-prod.tar,docker-compose.prod.yml"
          target: ${{ env.VPS_DEPLOY_PATH }}/
      
      - name: Create backup and organize files
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.VPS_SSH_PRIVATE_KEY }}
          port: 22
          script: |
            # Create images directory if it doesn't exist
            mkdir -p ${{ env.VPS_DEPLOY_PATH }}/images
            
            # Backup previous image if exists
            if [ -f ${{ env.VPS_DEPLOY_PATH }}/images/kesimarket-backend-prod-current.tar ]; then
              mv ${{ env.VPS_DEPLOY_PATH }}/images/kesimarket-backend-prod-current.tar ${{ env.VPS_DEPLOY_PATH }}/backups/kesimarket-backend-prod-backup-$(date +%Y%m%d-%H%M%S).tar
            fi
            
            # Move new image to images directory
            mv ${{ env.VPS_DEPLOY_PATH }}/kesimarket-backend-prod.tar ${{ env.VPS_DEPLOY_PATH }}/images/kesimarket-backend-prod-current.tar
            
            echo "‚úÖ Docker image organized successfully"

  load-and-run:
    name: Load and Run Services with Docker Compose
    runs-on: ubuntu-latest
    environment: production
    needs: [transfer-image]
    steps:
      - name: Deploy with Docker Compose
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.VPS_SSH_PRIVATE_KEY }}
          port: 22
          script: |
            cd ${{ env.VPS_DEPLOY_PATH }}
            
            # Detect if sudo is needed for Docker commands
            USE_SUDO=""
            if ! docker ps &> /dev/null; then
              if sudo docker ps &> /dev/null; then
                echo "‚ö†Ô∏è  Using sudo for Docker commands"
                USE_SUDO="sudo "
              else
                echo "‚ùå Docker not accessible even with sudo"
                exit 1
              fi
            else
              echo "‚úÖ Docker accessible without sudo"
            fi
            
            # Create production .env file
            cat > .env << EOF
            NODE_ENV=production
            PORT=3333
            HOST=0.0.0.0
            LOG_LEVEL=info
            APP_KEY=${{ secrets.APP_KEY }}
            
            # Database Configuration
            DB_CONNECTION=pg
            DB_HOST=db
            DB_PORT=5432
            DB_USER=${{ secrets.DB_USER }}
            DB_PASSWORD=${{ secrets.DB_PASSWORD }}
            DB_DATABASE=${{ secrets.DB_DATABASE }}
            
            # MinIO Configuration
            MINIO_HOST=minio
            MINIO_PORT=9000
            MINIO_ACCESS_KEY=${{ secrets.MINIO_ACCESS_KEY }}
            MINIO_SECRET_KEY=${{ secrets.MINIO_SECRET_KEY }}
            MINIO_USE_SSL=false
            MINIO_BUCKET=${{ secrets.MINIO_BUCKET }}
            MINIO_PUBLIC_ENDPOINT=${{ secrets.MINIO_PUBLIC_ENDPOINT }}
            MINIO_ROOT_USER=${{ secrets.MINIO_ROOT_USER }}
            MINIO_ROOT_PASSWORD=${{ secrets.MINIO_ROOT_PASSWORD }}
            MINIO_PUBLIC_ENDPOINT=${{ secrets.MINIO_PUBLIC_ENDPOINT }}
            
          # Redis Configuration (optional)
          REDIS_HOST=redis
          REDIS_PORT=6379
          REDIS_PASSWORD=${{ secrets.REDIS_PASSWORD }}
          
          # Typesense Configuration
          TYPESENSE_HOST=typesense
          TYPESENSE_PORT=8108
          TYPESENSE_API_KEY=${{ secrets.TYPESENSE_API_KEY }}
          
          # JWT Configuration
          JWT_SECRET=${{ secrets.JWT_SECRET }}
            
            # CORS Configuration
            CORS_ORIGINS=${{ secrets.CORS_ORIGINS }}
            
            # Email Configuration (optional)
            SMTP_HOST=${{ secrets.SMTP_HOST }}
            SMTP_PORT=${{ secrets.SMTP_PORT }}
            SMTP_USERNAME=${{ secrets.SMTP_USERNAME }}
            SMTP_PASSWORD=${{ secrets.SMTP_PASSWORD }}
            SMTP_FROM=${{ secrets.SMTP_FROM }}
            MAIL_USERNAME=${{ secrets.MAIL_USERNAME }}
            GOOGLE_APP_SECRET=${{ secrets.GOOGLE_APP_SECRET }}
            
            # Frontend URL
            FRONTEND_URL=${{ secrets.FRONTEND_URL }}
            
            # Storage Configuration
            STORAGE_DRIVER=minio
            EOF
            
            # Create .env file for docker-compose
            cat > .env << 'EOF'
            DB_USER=${{ secrets.DB_USER }}
            DB_PASSWORD=${{ secrets.DB_PASSWORD }}
            DB_DATABASE=${{ secrets.DB_DATABASE }}
            MINIO_ACCESS_KEY=${{ secrets.MINIO_ACCESS_KEY }}
            MINIO_SECRET_KEY=${{ secrets.MINIO_SECRET_KEY }}
            MINIO_BUCKET=${{ secrets.MINIO_BUCKET }}
            MINIO_PUBLIC_ENDPOINT=${{ secrets.MINIO_PUBLIC_ENDPOINT }}
            REDIS_PASSWORD=${{ secrets.REDIS_PASSWORD }}
            TYPESENSE_API_KEY=${{ secrets.TYPESENSE_API_KEY }}
            APP_KEY=${{ secrets.APP_KEY }}
            JWT_SECRET=${{ secrets.JWT_SECRET }}
            CORS_ORIGINS=${{ secrets.CORS_ORIGINS }}
            FRONTEND_URL=${{ secrets.FRONTEND_URL }}
            SMTP_HOST=${{ secrets.SMTP_HOST }}
            SMTP_PORT=${{ secrets.SMTP_PORT }}
            SMTP_USERNAME=${{ secrets.SMTP_USERNAME }}
            SMTP_PASSWORD=${{ secrets.SMTP_PASSWORD }}
            SMTP_FROM=${{ secrets.SMTP_FROM }}
            MAIL_USERNAME=${{ secrets.MAIL_USERNAME }}
            GOOGLE_APP_SECRET=${{ secrets.GOOGLE_APP_SECRET }}
            EOF
            
            echo "‚úÖ Environment file created for docker-compose"
            
            # Create shared Docker network if it doesn't exist
            echo "üåê Checking shared Docker network..."
            NETWORK_NAME="kesimarket-net"
            
            echo "üìã Current networks:"
            ${USE_SUDO}docker network ls
            
            # More precise network detection using exact name match
            if ${USE_SUDO}docker network inspect "$NETWORK_NAME" >/dev/null 2>&1; then
              echo "‚úÖ Network '$NETWORK_NAME' already exists and is accessible"
              ${USE_SUDO}docker network inspect "$NETWORK_NAME" --format 'Network: {{.Name}} ({{.Driver}})'
            else
              echo "üîß Network '$NETWORK_NAME' not found, creating..."
              if ${USE_SUDO}docker network create "$NETWORK_NAME" --driver bridge; then
                echo "‚úÖ Network '$NETWORK_NAME' created successfully!"
                
                # Verify creation
                if ${USE_SUDO}docker network inspect "$NETWORK_NAME" >/dev/null 2>&1; then
                  echo "‚úÖ Network creation verified"
                  ${USE_SUDO}docker network inspect "$NETWORK_NAME" --format 'Network: {{.Name}} ({{.Driver}})'
                else
                  echo "‚ùå Network verification failed after creation"
                  echo "üìã Available networks after creation:"
                  ${USE_SUDO}docker network ls
                  exit 1
                fi
              else
                echo "‚ùå Failed to create network '$NETWORK_NAME'"
                echo "üìã Docker network error details:"
                ${USE_SUDO}docker network create "$NETWORK_NAME" --driver bridge || true
                exit 1
              fi
            fi
            
            # Load the new Docker image
            ${USE_SUDO}docker load < images/kesimarket-backend-prod-current.tar
            
            # Tag the loaded image as latest for docker-compose
            IMAGE_NAME=$(${USE_SUDO}docker images --format "table {{.Repository}}:{{.Tag}}" | grep kesimarket-backend-prod | grep -v latest | head -n 1)
            ${USE_SUDO}docker tag $IMAGE_NAME kesimarket-backend-prod:latest
            
            # Stop existing services
            echo 'Stopping existing services...'
            ${USE_SUDO}docker compose -f docker-compose.prod.yml down || echo 'No existing services to stop'
            
            # Final network verification before starting services
            echo "üîç Final network verification before starting services..."
            if ! ${USE_SUDO}docker network ls | grep -q "kesimarket-net"; then
              echo "‚ùå CRITICAL: Network kesimarket-net still not found after creation attempt!"
              echo "üìã Available networks:"
              ${USE_SUDO}docker network ls
              exit 1
            fi
            
            echo "‚úÖ Network kesimarket-net confirmed ready"
            
            # Start infrastructure services first (db, minio, redis, typesense)
            echo 'Starting infrastructure services...'
            ${USE_SUDO}docker compose -f docker-compose.prod.yml up -d db minio redis typesense
            
            # Wait for database to be ready with better error handling
            echo "Waiting for database to be ready..."
            MAX_ATTEMPTS=30
            ATTEMPT=1
            
            while [ $ATTEMPT -le $MAX_ATTEMPTS ]; do
              echo "üîç Database check attempt $ATTEMPT/$MAX_ATTEMPTS..."
              
              if ${USE_SUDO}docker compose -f docker-compose.prod.yml exec -T db pg_isready -U ${{ secrets.DB_USER }} -d ${{ secrets.DB_DATABASE }}; then
                echo "‚úÖ Database is ready!"
                break
              else
                if [ $ATTEMPT -eq $MAX_ATTEMPTS ]; then
                  echo "‚ùå Database failed to start after $MAX_ATTEMPTS attempts"
                  echo "üìã Database container logs:"
                  ${USE_SUDO}docker compose -f docker-compose.prod.yml logs db
                  echo "üìã Database container status:"
                  ${USE_SUDO}docker ps -f name=kesimarket-postgres-prod
                  exit 1
                fi
                echo "‚è≥ Database not ready yet, waiting 5 seconds..."
                sleep 5
              fi
              ATTEMPT=$((ATTEMPT + 1))
            done
            
            # Create database if not exists
            echo "Creating database ${{ secrets.DB_DATABASE }} if not exists..."
            ${USE_SUDO}docker compose -f docker-compose.prod.yml exec -T db psql -U ${{ secrets.DB_USER }} -c "SELECT 'CREATE DATABASE \"${{ secrets.DB_DATABASE }}\"' WHERE NOT EXISTS (SELECT FROM pg_database WHERE datname = '${{ secrets.DB_DATABASE }}')\\gexec"
            
            # Wait for MinIO to be ready
            echo "Waiting for MinIO to be ready..."
            MAX_MINIO_ATTEMPTS=30
            MINIO_ATTEMPT=1
            
            while [ $MINIO_ATTEMPT -le $MAX_MINIO_ATTEMPTS ]; do
              echo "üîç MinIO check attempt $MINIO_ATTEMPT/$MAX_MINIO_ATTEMPTS..."
              
              if ${USE_SUDO}docker compose -f docker-compose.prod.yml exec -T minio curl -f http://localhost:9000/minio/health/live >/dev/null 2>&1; then
                echo "‚úÖ MinIO is ready!"
                break
              else
                if [ $MINIO_ATTEMPT -eq $MAX_MINIO_ATTEMPTS ]; then
                  echo "‚ùå MinIO failed to start after $MAX_MINIO_ATTEMPTS attempts"
                  echo "üìã MinIO container logs:"
                  ${USE_SUDO}docker compose -f docker-compose.prod.yml logs minio
                  exit 1
                fi
                echo "‚è≥ MinIO not ready yet, waiting 3 seconds..."
                sleep 3
              fi
              MINIO_ATTEMPT=$((MINIO_ATTEMPT + 1))
            done
            
            # Wait for Typesense to be ready
            echo "Waiting for Typesense to be ready..."
            MAX_TYPESENSE_ATTEMPTS=30
            TYPESENSE_ATTEMPT=1
            
            while [ $TYPESENSE_ATTEMPT -le $MAX_TYPESENSE_ATTEMPTS ]; do
              echo "üîç Typesense check attempt $TYPESENSE_ATTEMPT/$MAX_TYPESENSE_ATTEMPTS..."
              
              if ${USE_SUDO}docker compose -f docker-compose.prod.yml exec -T typesense curl -f http://localhost:8108/health >/dev/null 2>&1; then
                echo "‚úÖ Typesense is ready!"
                break
              else
                if [ $TYPESENSE_ATTEMPT -eq $MAX_TYPESENSE_ATTEMPTS ]; then
                  echo "‚ùå Typesense failed to start after $MAX_TYPESENSE_ATTEMPTS attempts"
                  echo "üìã Typesense container logs:"
                  ${USE_SUDO}docker compose -f docker-compose.prod.yml logs typesense
                  exit 1
                fi
                echo "‚è≥ Typesense not ready yet, waiting 3 seconds..."
                sleep 3
              fi
              TYPESENSE_ATTEMPT=$((TYPESENSE_ATTEMPT + 1))
            done
            
            # Verify database is accessible
            echo "Verifying database is accessible..."
            ${USE_SUDO}docker compose -f docker-compose.prod.yml exec -T db psql -U ${{ secrets.DB_USER }} -d "${{ secrets.DB_DATABASE }}" -c "SELECT 1;" > /dev/null
            echo "Database is ready!"
            
            # Give infrastructure services a moment to settle
            echo "Waiting 10 seconds before starting application..."
            sleep 10
            
            # Start application service
            echo 'Starting application service...'
            ${USE_SUDO}docker compose -f docker-compose.prod.yml up -d app
            
            # Wait for services to start
            echo 'Waiting for services to start...'
            sleep 15
            
            # Check if services are running
            echo 'Checking service status...'
            echo 'üìã Container Status:'
            ${USE_SUDO}docker ps -f name=kesimarket- --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
            
            # Check application container
            app_running=$(${USE_SUDO}docker ps -q -f name=${{ env.CONTAINER_NAME }})
            
            if [ ! -z "$app_running" ]; then
              echo '‚úÖ Application container is running!'
            else
              echo '‚ùå Application container failed to start!'
              ${USE_SUDO}docker compose -f docker-compose.prod.yml logs app
              exit 1
            fi
            
            echo 'Deployment completed - services are starting up...'

  run-migrations:
    name: Run Database Migrations
    runs-on: ubuntu-latest
    environment: production
    needs: [load-and-run]
    if: ${{ github.event.inputs.run_migrations == 'true' || github.event_name == 'push' }}
    steps:
      - name: Run migrations
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.VPS_SSH_PRIVATE_KEY }}
          port: 22
          script: |
            cd ${{ env.VPS_DEPLOY_PATH }}
            
            # Detect if sudo is needed for Docker commands
            USE_SUDO=""
            if ! docker ps &> /dev/null; then
              if sudo docker ps &> /dev/null; then
                echo "‚ö†Ô∏è  Using sudo for Docker commands"
                USE_SUDO="sudo "
              else
                echo "‚ùå Docker not accessible even with sudo"
                exit 1
              fi
            fi
            
            echo "Running database migrations..."
            ${USE_SUDO}docker compose -f docker-compose.prod.yml exec -T app node ace migration:run --force
            
            if [ $? -eq 0 ]; then
              echo "‚úÖ Migrations completed successfully!"
            else
              echo "‚ùå Migration failed!"
              ${USE_SUDO}docker compose -f docker-compose.prod.yml logs app
              exit 1
            fi

  setup-minio:
    name: Setup MinIO Configuration
    runs-on: ubuntu-latest
    environment: production
    needs: [run-migrations]
    steps:
      - name: Setup MinIO buckets and configuration
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.VPS_SSH_PRIVATE_KEY }}
          port: 22
          script: |
            cd ${{ env.VPS_DEPLOY_PATH }}
            
            # Detect if sudo is needed for Docker commands
            USE_SUDO=""
            if ! docker ps &> /dev/null; then
              if sudo docker ps &> /dev/null; then
                echo "‚ö†Ô∏è  Using sudo for Docker commands"
                USE_SUDO="sudo "
              else
                echo "‚ùå Docker not accessible even with sudo"
                exit 1
              fi
            fi
            
            echo "üöÄ Setting up MinIO configuration..."
            
            # Check MinIO configuration first
            echo "üìã Checking MinIO configuration..."
            ${USE_SUDO}docker compose -f docker-compose.prod.yml exec -T app node ace minio:check || echo "‚ö†Ô∏è  MinIO check failed, but continuing..."
            
            # Setup MinIO buckets with application
            echo "üì¶ Setting up MinIO buckets..."
            if ${USE_SUDO}docker compose -f docker-compose.prod.yml exec -T app node ace minio:setup; then
              echo "‚úÖ MinIO configuration completed successfully!"
            else
              echo "‚ùå MinIO setup failed!"
              ${USE_SUDO}docker compose -f docker-compose.prod.yml logs app
              echo "üìã MinIO container logs:"
              ${USE_SUDO}docker compose -f docker-compose.prod.yml logs minio
              exit 1
            fi

  run-seeds:
    name: Run Database Seeds
    runs-on: ubuntu-latest
    environment: production
    needs: [setup-minio]
    if: ${{ github.event.inputs.run_seeds == 'true' && (github.event.inputs.run_migrations == 'true' || github.event_name == 'push') }}
    steps:
      - name: Run seeds
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.VPS_SSH_PRIVATE_KEY }}
          port: 22
          script: |
            cd ${{ env.VPS_DEPLOY_PATH }}
            
            # Detect if sudo is needed for Docker commands
            USE_SUDO=""
            if ! docker ps &> /dev/null; then
              if sudo docker ps &> /dev/null; then
                echo "‚ö†Ô∏è  Using sudo for Docker commands"
                USE_SUDO="sudo "
              else
                echo "‚ùå Docker not accessible even with sudo"
                exit 1
              fi
            fi
            
            SEED_TYPE="${{ github.event.inputs.seed_type || 'production' }}"
            echo "Running database seeds (type: $SEED_TYPE)..."
            
            if [ "$SEED_TYPE" = "production" ]; then
              # Run main seeder which should handle production data
              ${USE_SUDO}docker compose -f docker-compose.prod.yml exec -T app node ace db:seed --files="database/seeders/main_seeder.ts"
            else
              # Run all seeders for development data
              ${USE_SUDO}docker compose -f docker-compose.prod.yml exec -T app node ace db:seed
            fi
            
            if [ $? -eq 0 ]; then
              echo "‚úÖ Seeds completed successfully!"
            else
              echo "‚ùå Seeds failed!"
              ${USE_SUDO}docker compose -f docker-compose.prod.yml logs app
              exit 1
            fi

  health-check:
    name: Final Health Check
    runs-on: ubuntu-latest
    environment: production
    needs: [load-and-run]
    if: always()
    steps:
      - name: Perform comprehensive health check
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.VPS_SSH_PRIVATE_KEY }}
          port: 22
          script: |
            cd ${{ env.VPS_DEPLOY_PATH }}
            
            # Detect if sudo is needed for Docker commands
            USE_SUDO=""
            if ! docker ps &> /dev/null; then
              if sudo docker ps &> /dev/null; then
                echo "‚ö†Ô∏è  Using sudo for Docker commands"
                USE_SUDO="sudo "
              else
                echo "‚ùå Docker not accessible even with sudo"
                exit 1
              fi
            fi
            
            echo "=== COMPREHENSIVE HEALTH CHECK ==="
            
            # Check container status
            echo "üìã Container Status:"
            ${USE_SUDO}docker ps -f name=kesimarket- --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
            
            # Check infrastructure services
            echo -e "\nüîç Infrastructure Services Status:"
            echo "Database:"
            ${USE_SUDO}docker ps -f name=kesimarket-postgres-prod --format "  {{.Names}}: {{.Status}}" || echo "  Not running"
            echo "MinIO:"
            ${USE_SUDO}docker ps -f name=kesimarket-minio-prod --format "  {{.Names}}: {{.Status}}" || echo "  Not running"
            echo "Redis:"
            ${USE_SUDO}docker ps -f name=kesimarket-redis-prod --format "  {{.Names}}: {{.Status}}" || echo "  Not running"
            echo "Typesense:"
            ${USE_SUDO}docker ps -f name=kesimarket-typesense-prod --format "  {{.Names}}: {{.Status}}" || echo "  Not running"
            
            # Check application logs (last 10 lines)
            echo -e "\nüìù Application Logs (last 10 lines):"
            ${USE_SUDO}docker compose -f docker-compose.prod.yml logs --tail=10 app
            
            # Test database connection (optional check)
            echo -e "\nüóÑÔ∏è  Database Connection Test:"
            if ${USE_SUDO}docker compose -f docker-compose.prod.yml exec -T app node ace migration:status > /dev/null 2>&1; then
              echo "‚úÖ Database connection successful"
            else
              echo "‚ö†Ô∏è  Database connection test failed (services may still be starting)"
            fi
            
            # Test MinIO connection (optional check)
            echo -e "\nüì¶ MinIO Connection Test:"
            if ${USE_SUDO}docker compose -f docker-compose.prod.yml exec -T app node ace minio:check > /dev/null 2>&1; then
              echo "‚úÖ MinIO connection successful"
            else
              echo "‚ö†Ô∏è  MinIO connection test failed (services may still be starting)"
            fi
            
            # Test Typesense connection (optional check)
            echo -e "\nüîç Typesense Connection Test:"
            if ${USE_SUDO}docker compose -f docker-compose.prod.yml exec -T typesense curl -f http://localhost:8108/health > /dev/null 2>&1; then
              echo "‚úÖ Typesense connection successful"
            else
              echo "‚ö†Ô∏è  Typesense connection test failed (services may still be starting)"
            fi
            
            # Simple container check instead of API test
            echo -e "\nüåê Application Status:"
            app_running=$(${USE_SUDO}docker ps -q -f name=kesimarket-backend-prod)
            
            if [ ! -z "$app_running" ]; then
              echo "‚úÖ Application container is running"
            else
              echo "‚ùå Application container not running"
            fi
            
            # Check disk space
            echo -e "\nüíæ Disk Space:"
            df -h ${{ env.VPS_DEPLOY_PATH }}
            
            echo -e "\n=== HEALTH CHECK COMPLETE ==="

  cleanup:
    name: Cleanup
    runs-on: ubuntu-latest
    environment: production
    needs: [load-and-run]
    if: always()
    steps:
      - name: Cleanup old Docker images and files
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.VPS_SSH_PRIVATE_KEY }}
          port: 22
          script: |
            # Detect if sudo is needed for Docker commands
            USE_SUDO=""
            if ! docker ps &> /dev/null; then
              if sudo docker ps &> /dev/null; then
                echo "‚ö†Ô∏è  Using sudo for Docker commands"
                USE_SUDO="sudo "
              else
                echo "‚ùå Docker not accessible even with sudo"
                exit 1
              fi
            fi
            
            # Remove dangling images
            ${USE_SUDO}docker image prune -f
            
            # Keep only the 3 most recent backup images
            cd ${{ env.VPS_DEPLOY_PATH }}/backups
            ls -t kesimarket-backend-prod-backup-*.tar 2>/dev/null | tail -n +4 | xargs -r rm -f
            
            # Clean up old logs (keep last 7 days)
            find ${{ env.VPS_DEPLOY_PATH }} -name "*.log" -type f -mtime +7 -delete 2>/dev/null || true
            
            echo "‚úÖ Cleanup completed"

      - name: Deployment Summary
        run: |
          echo "## üöÄ KesiMarket Modern Backend Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Setting | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|---------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| **Environment** | Production |" >> $GITHUB_STEP_SUMMARY
          echo "| **Repository** | ${{ github.repository }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Commit** | ${{ github.sha }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Run Migrations** | ${{ github.event.inputs.run_migrations || 'auto (on push)' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Run Seeds** | ${{ github.event.inputs.run_seeds || 'false' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Seed Type** | ${{ github.event.inputs.seed_type || 'production' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Container** | ${{ env.CONTAINER_NAME }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Port** | ${{ env.CONTAINER_PORT }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Deploy Path** | ${{ env.VPS_DEPLOY_PATH }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üìã Services Deployed" >> $GITHUB_STEP_SUMMARY
          echo "- üöÄ **KesiMarket Backend** (AdonisJS 6)" >> $GITHUB_STEP_SUMMARY
          echo "- üóÑÔ∏è **PostgreSQL Database**" >> $GITHUB_STEP_SUMMARY
          echo "- üì¶ **MinIO Object Storage**" >> $GITHUB_STEP_SUMMARY
          echo "- üóÉÔ∏è  **Redis Cache** (optional)" >> $GITHUB_STEP_SUMMARY
          echo "- üîç **Typesense Search Engine**" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üîó Next Steps" >> $GITHUB_STEP_SUMMARY
          echo "1. Verify API endpoints are responding correctly" >> $GITHUB_STEP_SUMMARY
          echo "2. Test file upload functionality" >> $GITHUB_STEP_SUMMARY
          echo "3. Check application logs for any issues" >> $GITHUB_STEP_SUMMARY
          echo "4. Update frontend environment variables if needed" >> $GITHUB_STEP_SUMMARY
